import random

# Objective function (we want to minimize this)
def objective_function(position):
    x, y = position
    return x**2 + y**2   # Minimum is 0 at (0,0)

# Particle class
class Particle:
    def __init__(self, bounds):
        self.position = [random.uniform(bounds[0], bounds[1]) for _ in range(2)]
        self.velocity = [random.uniform(-1, 1) for _ in range(2)]
        self.best_position = list(self.position)
        self.best_value = objective_function(self.position)

    def update_velocity(self, global_best_position, w, c1, c2):
        for i in range(len(self.position)):
            r1 = random.random()
            r2 = random.random()
            cognitive = c1 * r1 * (self.best_position[i] - self.position[i])
            social = c2 * r2 * (global_best_position[i] - self.position[i])
            self.velocity[i] = w * self.velocity[i] + cognitive + social

    def update_position(self, bounds):
        for i in range(len(self.position)):
            self.position[i] += self.velocity[i]
            # Clamp to bounds
            if self.position[i] < bounds[0]:
                self.position[i] = bounds[0]
            if self.position[i] > bounds[1]:
                self.position[i] = bounds[1]

        # Update personal best if improved
        current_value = objective_function(self.position)
        if current_value < self.best_value:
            self.best_value = current_value
            self.best_position = list(self.position)


# PSO algorithm
def PSO(num_particles, max_iterations, bounds, w=1.2, c1=0.7, c2=1.5):
    # Initialize swarm
    swarm = [Particle(bounds) for _ in range(num_particles)]

    # Initialize global best
    global_best_position = min(swarm, key=lambda p: p.best_value).best_position
    global_best_value = objective_function(global_best_position)

    # Main loop
    for iteration in range(max_iterations):
        for particle in swarm:
            particle.update_velocity(global_best_position, w, c1, c2)
            particle.update_position(bounds)

        # Update global best
        for particle in swarm:
            if particle.best_value < global_best_value:
                global_best_value = particle.best_value
                global_best_position = list(particle.best_position)

        print(f"Iteration {iteration+1}: Best Fitness = {global_best_value:.6f} at {global_best_position}")

    print("\nFinal Best Solution:")
    print("Position =", global_best_position)
    print("Fitness Value =", global_best_value)


# Run PSO
if __name__ == "__main__":
    PSO(num_particles=5, max_iterations=10, bounds=[-10, 10])
